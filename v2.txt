

data ParseError err
  = InvalidJSON String
  | KeyMissing Text
  | OutOfBounds Int
  | WrongType JSONType JSONType
  | CustomError err

runParse :: Parse err a -> BL.ByteString -> Either (ParseError err) a

parseBower :: Parse MyErr BowerJson
parseBower =
  BowerJson <$> key "name" asString
            <*> maybeKey "description" asString
            <*> keyOr "main"       [] (eachInArray asString)
            <*> keyOr "moduleType" [] (eachInArray parseModuleType)
            <*> keyOr "licence"    [] (eachInArray takeString)
                [...]
            <*> keyOr "authors" [] (eachInArray parseAuthor)




key :: Text -> Parse err a -> Parse err a

asText :: Parse err Text
asString :: Parse err String

asObject :: Parse err A.Object
asArray :: Parse err A.Array

maybeKey :: Text -> Parse err a -> Parse err (Maybe a)

eachInArray :: Parse err a -> Parse err [a]

parseModuleType :: Parse err ModuleType

eachInArray parseModuleType :: Parse err [ModuleType]

parseModuleType' :: Text -> Either err ModuleType

withText :: (Text -> Parse err a) -> Parse err a
withScientific :: (Scientific -> Parse err a) -> Parse err a

moduleTypeFromText :: Text -> Parse MyErr ModuleType
moduleTypeFromText t =
  case lookup t moduleTypes of
    Just ty -> pure ty
    Nothing -> throwE (InvalidModuleType t)

parseModuleType = withText moduleTypeFromText


withValue :: (A.Value -> Parse err a) -> Parse err a

parseAuthor :: A.Value -> Parse MyErr Author
parseAuthor (A.Object obj) = ...
parseAuthor (A.String str) = ...
parseAuthor val = throwE (InvalidAuthor val)

-- Alternative - use monoid, combine errors?
-- Simply take rightmost?
